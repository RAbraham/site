<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.2.335">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2020-09-11">
<meta name="description" content="In this post, I’ll gradually build up to a naive implementation of the Datalog engine in Python">

<title>site - An Unnecessarily Long-Winded Introduction to the Essence of Datalog</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>


<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">site</span>
    </a>
  </div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../about.html">
 <span class="menu-text">About me</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/"><i class="bi bi-github" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com"><i class="bi bi-twitter" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
</ul>
              <div id="quarto-search" class="" title="Search"></div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">An Unnecessarily Long-Winded Introduction to the Essence of Datalog</h1>
                  <div>
        <div class="description">
          In this post, I’ll gradually build up to a naive implementation of the Datalog engine in Python
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">markdown</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">September 11, 2020</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#datalog-concepts" id="toc-datalog-concepts" class="nav-link active" data-scroll-target="#datalog-concepts">Datalog Concepts</a></li>
  <li><a href="#simple-relation-query" id="toc-simple-relation-query" class="nav-link" data-scroll-target="#simple-relation-query">Simple Relation Query</a></li>
  <li><a href="#simple-rule-query" id="toc-simple-rule-query" class="nav-link" data-scroll-target="#simple-rule-query">Simple Rule Query</a></li>
  <li><a href="#test-cases" id="toc-test-cases" class="nav-link" data-scroll-target="#test-cases">Test Cases</a>
  <ul class="collapse">
  <li><a href="#logical-or-query" id="toc-logical-or-query" class="nav-link" data-scroll-target="#logical-or-query">Logical OR Query</a></li>
  <li><a href="#extra-extra.-read-all-about-it" id="toc-extra-extra.-read-all-about-it" class="nav-link" data-scroll-target="#extra-extra.-read-all-about-it">Extra Extra. Read All About It</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">




<p>+++</p>
<p><a href="https://rabraham.github.io/mercylog/teaching/essence.html">This</a> is a better formatted post. Don’t read below.</p>
<p>+++</p>
<section id="datalog-concepts" class="level2">
<h2 class="anchored" data-anchor-id="datalog-concepts">Datalog Concepts</h2>
<p>Let’s start with a simple Datalog Program.</p>
<p>We can have simple <code>facts</code> in our database. e.g.&nbsp;Bob is a man. Abe is a man. In Datalog, we write it as:</p>
<pre><code>man("Bob")
man("Abe")</code></pre>
<p><code>man</code> is like a table in a database. <code>man("Bob")</code> is a relation in that table. We’ll also call it a <code>base</code> relation.</p>
<p>Next, we create the business logic i.e.&nbsp;<code>rules</code>.</p>
<p>Someone is a person if he is a man <code>person(X) :- man(X)</code></p>
<p><code>person(X)</code> is a <code>derived</code> relation, as it is derived from some base relation <code>man(X)</code>. This is similar to a view in the database.</p>
<p><code>X</code> is a <code>logical variable</code>. So <code>man(X)</code> could be used to refer to all <code>man</code> relations in the database.</p>
<p><code>{code-cell} ipython3 from typing import * from dataclasses import dataclass from pprint import pprint</code></p>
<p>We can create a logical variable like this:</p>
<p><code>{code-cell} ipython3 @dataclass(frozen=True) class Variable:     name: str</code></p>
<p><code>{code-cell} ipython3 X = Variable('X')</code></p>
<p>A relation could be:</p>
<p><code>man("Bob")</code></p>
<p><code>parent("John", "Chester")</code> # John is a parent of Chester</p>
<p>It could also be components of a rule e.g. <code>man(X)</code> or <code>person(X)</code> in <code>person(X) :- man(X)</code></p>
<p>So a relation has a name(e.g.&nbsp;<code>parent</code>) and a list of attributes(e.g.&nbsp;<code>"John"</code> and <code>"Chester"</code> or <code>X</code>).</p>
<p>```{code-cell} ipython3 <span class="citation" data-cites="dataclass">@dataclass</span>(frozen=True, eq=True) class Relation: ““” man(“Bob) is Relation(”man”, (“Bob”,)) # (“Bob”,) is a single valued tuple parent(“John”, “Chester”) is Relation(“parent”, (“John”, “Chester”)) man(X) is Relation(“man”, (Variable(“X”),))</p>
<pre><code>"""
name: str
attributes: Tuple</code></pre>
<pre><code>
A rule could be:
- `person(X) :- man(X)` i.e. `X` is a person if he is man.
- `father(X, Y) :- man(X), parent(X, Y)` i.e. `X` is a father of `Y` if `X` is a man and `X` is the parent of `Y`

A rule has:
- a head relation which is on the left of the `:-` symbol e.g. `person(X)` and `father(X, Y)` above
- a body of relations which is on the right of the `:-` symbol e.g. `man(X)` and `man(X), parent(X, Y)` above

Since Datalog is declarative, the order of the relations in the body does not matter. Both the statements below have the same meaning:

`father(X, Y) :- man(X), parent(X, Y)`

`father(X, Y) :- parent(X, Y), man(X)` # reversing the order does not matter

So, the body can be represented as a set

```{code-cell} ipython3
@dataclass(frozen=True, eq=True)
class Rule:
    head: Relation
    body: Set[Relation]</code></pre>
<p>The last element of Datalog is the query. The simplest query is no rules, just facts.</p>
<p>Given:</p>
<pre><code>man("Abe)
man("Bob")
woman("Abby")</code></pre>
<p>A query could be: <code>man(X)</code> # Find me all men</p>
<p>The query should return: <code>{man("Bob"), man("George")}</code></p>
<p>This would be similar to a SQL query <code>select * from man</code></p>
<p>+++</p>
</section>
<section id="simple-relation-query" class="level2">
<h2 class="anchored" data-anchor-id="simple-relation-query">Simple Relation Query</h2>
<p>+++</p>
<p>The simplest query is to find a matching relation. Taking the above example, let’s code that up in Python.</p>
<p><code>{code-cell} ipython3 X = Variable('X') abe = Relation("man", ("Abe",)) bob = Relation("man", ("Bob",)) abby = Relation("woman", ("Abby",)) database = {abe, bob, abby} no_rules = []  query = Relation("man", (X,))</code></p>
<p>For some function <code>run_simplest</code>, I expect: <code>assert run_simplest(database, no_rules, query) == {abe, bob}</code></p>
<p>The simplest run would iterate through all the facts and filter those facts that match the query by relation name.</p>
<p>```{code-cell} ipython3 def name_match(fact: Relation, query: Relation) -&gt; bool: return fact.name == query.name</p>
<p>def filter_facts(database: Set[Relation], query: Relation, match: Callable) -&gt; Set[Relation]: return {fact for fact in database if match(fact, query)}</p>
<p>def run_simplest(database: Set[Relation], rules: List[Rule], query: Relation) -&gt; Set[Relation]: return filter_facts(database, query, name_match)</p>
<p>assert run_simplest(database, no_rules, query) == {abe, bob}</p>
<pre><code>
Let's add some facts of length two:
</code></pre>
<p>parent(“Abe”, “Bob”) # Abe is a parent of Bob parent(“Abby”, “Bob”) parent(“Bob”, “Carl”) parent(“Bob”, “Connor”) parent(“Beatrice”, “Carl”)</p>
<pre><code>
I may want to query who are the parents of Carl


`parent(X, "Carl")` should return `{parent("Bob", "Carl"), parent("Beatrice", "Carl")}`

`parent(X, "Carl")` is similar to `select * from parent where child = "Carl"` if there was a table `parent` with columns `parent` and `child`)

The beauty of Datalog is that you can ask the inverse without additional code e.g. Who are the children of Bob

`parent("Bob", X)` should return `{parent("Bob", "Carl"), parent("Bob", "Connor")}`


Let's code that up. Also from now on, I'm going to make a helper functions to make it easy to express relations like the lambda `parent` below.

```{code-cell} ipython3
parent = lambda parent, child: Relation("parent", (parent, child))
database = {
    parent("Abe", "Bob"), # Abe is a parent of Bob
    parent("Abby", "Bob"),
    parent("Bob", "Carl"),
    parent("Bob", "Connor"),
    parent("Beatrice", "Carl")
}</code></pre>
<p>Now, to the implementation. For a query to match, an argument at position N in the query should match the argument at position N in the fact. For e.g <code>assert query_variable_match(parent("A", "Bob"), parent(X, "Bob") ) == True</code></p>
<p>Logical variables are special. They get a free pass like <code>X</code> above.</p>
<p>```{code-cell} ipython3 def query_variable_match(fact: Relation, query: Relation) -&gt; bool: if fact.name != query.name: return False</p>
<pre><code># TODO: zip is duplicated?
for query_attribute, fact_attribute in zip(query.attributes, fact.attributes):
    if not isinstance(query_attribute, Variable) and query_attribute != fact_attribute:
            return False
return True  </code></pre>
<p>assert query_variable_match(parent(“A”, “Bob”), parent(X, “Bob”) ) == True assert query_variable_match(parent(“A”, “Bob”), parent(“A”, X)) == True assert query_variable_match(parent(“A”, “NoMatch”), parent(X, “Bob”) ) == False</p>
<p>def run_with_filter(database: Set[Relation], rules: List[Rule], query: Relation) -&gt; Set[Relation]: return filter_facts(database, query, query_variable_match)</p>
<pre><code>
So does it work?

```{code-cell} ipython3
parents_carl =  run_with_filter(database, [], parent(X, "Carl")) 
assert parents_carl == {parent("Bob", "Carl"), parent("Beatrice", "Carl")}

children_bob =  run_with_filter(database, [], parent("Bob", X)) 
assert children_bob == {parent("Bob", "Carl"), parent("Bob", "Connor")}</code></pre>
</section>
<section id="simple-rule-query" class="level2">
<h2 class="anchored" data-anchor-id="simple-rule-query">Simple Rule Query</h2>
<p>Let’s add a rule to our program.</p>
<pre><code>human(X) :- man(X) # You are human if you are man.</code></pre>
<p>An example database below:</p>
<pre><code>man("Bob")
man("George")
animal("Tiger")</code></pre>
<p>Query:</p>
<p><code>human(X)</code> # Find me all humans</p>
<p>The query should return: <code>{human("Bob"), human("George")}</code></p>
<p>```{code-cell} ipython3 man = lambda x: Relation(“man”, (x,)) animal = lambda x: Relation(“animal”, (x,)) human = lambda x: Relation(“human”, (x,)) X = Variable(“X”)</p>
<p>head = human(X) body = [man(X)] human_rule = Rule(head, body) # No pun was intended database = { man(“Abe”), man(“Bob”), animal(“Tiger”) } rules = [human_rule] query = human(X)</p>
<pre><code>
For each rule, for each relation in it's body, if it matches with any of the facts in the database,
then get the attributes of that fact and create a derived relation with those attributes.
E.g., since we have `man("Abe")` and our rule `human(X) :- man(X)`, we add a derived relation to our database `human("Abe")`

```{code-cell} ipython3
def match_relation_and_fact(relation: Relation, fact: Relation) -&gt; Optional[Dict]:
    if relation.name == fact.name:
        return dict(zip(relation.attributes, fact.attributes))

def match_relation_and_database(database: Set[Relation], relation: Relation) -&gt; List[Dict]:
    inferred_attributes = []
    for fact in database:
        attributes = match_relation_and_fact(relation, fact)
        if attributes:
            inferred_attributes.append(attributes)
    return inferred_attributes


def evaluate_rule_simple(rule: Rule, database: Set[Relation]) -&gt; Set[Relation]:
    relation = list(rule.body)[0] # For now, our body has only one relation
    all_matches = match_relation_and_database(database, relation)
    # We use the Python feature below that if we call `values` on a dictionary, 
    # it will preserve the order that was given when the dictionary was created
    # i.e. in the `zip` inside `match_relation_and_database`. Thank God.
    return {Relation(rule.head.name, tuple(attributes.values())) for attributes in all_matches}</code></pre>
<p>This <code>evaluate_rule_simple</code> can be passed to a function which will <code>evaluate</code> it on each rule for the database to generate the final knowledge base.</p>
<p><code>{code-cell} ipython3 def generate_knowledgebase(evaluate: Callable, database: Set[Relation], rules: List[Rule]):     knowledge_base = database      for rule in rules:         evaluation = evaluate(rule, database)         knowledge_base = knowledge_base.union(evaluation)     return knowledge_base</code></p>
<p>And finally, we have</p>
<p>```{code-cell} ipython3 def run_rule_simple(database: Set[Relation], rules: List[Rule], query: Relation): knowledge_base = generate_knowledgebase(evaluate_rule_simple, database, rules) return filter_facts(knowledge_base, query, query_variable_match)</p>
</section>
<section id="test-cases" class="level1">
<h1>Test Cases</h1>
<p>simplest_rule_result = run_rule_simple(database, rules, query) assert simplest_rule_result == {human(“Abe”), human(“Bob”)}, f”result was {simplest_rule_result}”</p>
<pre><code>
## Logical AND Query

+++

Next, we introduce logical AND(conjunction). i.e. Given
</code></pre>
<p>parent(“Abe”, “Bob”), # Abe is a parent of Bob parent(“Abby”, “Bob”), parent(“Bob”, “Carl”), parent(“Bob”, “Connor”), parent(“Beatrice”, “Carl”), man(“Abe”), man(“Bob”), woman(“Abby”), woman(“Beatrice”)</p>
<pre><code>
We'd like to find all the fathers in the house. A person is a father if he is a parent and he is a man. i.e.
`father(X, Y) :- parent(X, Y), man(X)`

```{code-cell} ipython3
X = Variable("X")
Y = Variable("Y")
woman = lambda x: Relation("woman", (x,))
father = lambda x, y: Relation("father", (x, y))

database = {
    parent("Abe", "Bob"), # Abe is a parent of Bob
    parent("Abby", "Bob"),
    parent("Bob", "Carl"),
    parent("Bob", "Connor"),
    parent("Beatrice", "Carl"),
    man("Abe"),
    man("Bob"),
    woman("Abby"),
    woman("Beatrice")
}

father_rule = Rule(father(X, Y), {parent(X, Y), man(X)})
rules = [father_rule]
query = father(X, Y)</code></pre>
<p>How does the match change? We need to add logic for the conjunction i.e.&nbsp;when we match the body to the facts, we have to check if the attributes of the facts match across the entire body, e.g.&nbsp;for the body <code>parent(X, Y), man(X)</code> * parent(“Abe”, “Bob”), man(“Abe”) is a match as there is a common value <code>Abe</code> across the entire body at same place as <code>X</code>. * parent(“Abby”, “Bob”) does not match as there is no <code>man("Abby")</code>.</p>
<p>Let’s first code up this common value logic as <code>has_common_value</code>. We also have to start pairing variables to values e.g.&nbsp;<code>{'X': 'Abe'}</code></p>
<p>This combination below:</p>
<p><code>has_common_value({ X: 'Abe', Y: 'Bob'}, {X: 'Abe'})</code> should return <code>True</code></p>
<p><code>{code-cell} ipython3 def has_common_value(attrs1: Dict[Variable, Any], attrs2: Dict[Variable, Any]) -&gt; bool:     common_vars = set(attrs1.keys()).intersection(set(attrs2.keys()))     return all([attrs1[c] == attrs2[c] for c in common_vars])</code></p>
<p>Once we have that, we know that <code>match_relation_and_database</code> will return as before, a list of body attributes which each match a fact in the database. It’s time to conjunct. We may get some input like:</p>
<pre><code>[[{X: 'Bob', Y: 'Carl'},    # &lt;= All facts that match parent(X,Y)
  {X: 'Beatrice', Y: 'Carl'},
  {X: 'Abe', Y: 'Bob'},
  {X: 'Abby', Y: 'Bob'},
  {X: 'Bob', Y: 'Connor'}],
 [{X: 'Bob'},               # &lt;= All facts that match man(X)
  {X: 'Abe'}]]</code></pre>
<p>For the body <code>man(X), parent(X, Y)</code>, we expect back from a function <code>conjunct</code>:</p>
<pre><code>[{X: 'Bob', Y: 'Carl'},
 {X: 'Abe', Y: 'Bob'},
 {X: 'Bob', Y: 'Connor'}]</code></pre>
<p>Just hacking it for now.</p>
<p>```{code-cell} ipython3 def conjunct(body_attributes: List[List[Dict]]) -&gt; List: # TODO: Does not cover body lengths greater than 2 result = [] if len(body_attributes) == 1: return body_attributes[0]</p>
<pre><code>attr1 = body_attributes[0]
attr2 = body_attributes[1]
for a1 in attr1:
    for a2 in attr2:
        _c = has_common_value(a1, a2)
        if _c:
            result.append({**a1, **a2})
return result</code></pre>
<pre><code>
I also realized that though the body can return many attributes which have 'conjuncted', we only need those which are in the head.
e.g. for a rule `relation1(X) :- relation2(X,Y), relation3(X)`, `relation1` just needs `X` so I'll just pull that.

```{code-cell} ipython3
def rule_attributes(relation: Relation, attr: Dict[Variable, Any]) -&gt; Tuple:
    return tuple([attr[a] for a in relation.attributes])</code></pre>
<p>So the final <code>evaluate</code> function becomes</p>
<p>```{code-cell} ipython3 def evaluate_logical_operators_in_rule(rule: Rule, database: List[Relation]) -&gt; Set[Relation]: body_attributes = []</p>
<pre><code>for relation in rule.body:
    _attributes = match_relation_and_database(database, relation)
    body_attributes.append(_attributes)

attributes = conjunct(body_attributes)

return {Relation(rule.head.name, rule_attributes(rule.head, attr)) for attr in attributes}</code></pre>
<p>def run_logical_operators(database: Set[Relation], rules: List[Rule], query: Relation): knowledge_base = generate_knowledgebase(evaluate_logical_operators_in_rule, database, rules) return filter_facts(knowledge_base, query, query_variable_match)</p>
<pre><code>
Let's test that it works for single relation bodies, preventing any regressions.

```{code-cell} ipython3
simple_conjunct_rules = [Rule(human(X), {man(X)})]
assert run_logical_operators(database, simple_conjunct_rules, human(X)) == {human("Abe"), human("Bob")}</code></pre>
<p>And our final test</p>
<p><code>{code-cell} ipython3 assert run_logical_operators(database, rules, query) == {father("Abe", "Bob"), father("Bob", "Carl"), father("Bob", "Connor")}</code></p>
<section id="logical-or-query" class="level2">
<h2 class="anchored" data-anchor-id="logical-or-query">Logical OR Query</h2>
<p>+++</p>
<p>Logical OR is just specifying two separate rules with the same head. E.g.</p>
<pre><code>human(X) :- man(X)
human(X) :- woman(X)</code></pre>
<p>In Python, given:</p>
<p>```{code-cell} ipython3 database = { animal(“Tiger”), man(“Abe”), man(“Bob”), woman(“Abby”), woman(“Beatrice”) }</p>
<p>man_rule = Rule(human(X), {man(X)}) woman_rule = Rule(human(X), {woman(X)}) rules = [man_rule, woman_rule] query = human(X)</p>
<p>assert run_logical_operators(database, rules, query) == { human(“Abe”), human(“Bob”), human(“Abby”), human(“Beatrice”) }</p>
<pre><code>
## Recursive Relations Query

+++

Next, we introduce the reason why we are interested in Datalog. Datalog intuitively captures hierarchies or recursion. E.g. we want to find all who are ancestors of someone.
Given:</code></pre>
<p>parent(“A”, “B”) # A is the parent of B parent(“B”, “C”) parent(“C”, “D”) parent(“AA”, “BB”) parent(“BB”, “CC”)</p>
<pre><code>
A parent X of Y is by definition an ancestor.

`ancestor(X, Y) :- parent(X, Y)`

If you are a parent of Y and Y is an an ancestor, then you are an ancestor as well.

`ancestor(X, Z) :- parent(X, Y), ancestor(Y, Z)`

Query: `ancestor(X, Y)` should return all the parents above as ancestors </code></pre>
<p>ancestor(“A”, “B”) # A is the ancestor of B ancestor(“A”, “C”) # A -&gt; B -&gt; C ancestor(“A”, “D”) # A -&gt; B -&gt; C -&gt; D ancestor(“B”, “C”) ancestor(“B”, “D”) # B -&gt; C -&gt; D ancestor(“C”, “D”) ancestor(“AA”, “BB”) ancestor(“AA”, “CC”) # AA -&gt; BB -&gt; CC ancestor(“BB”, “CC”)</p>
<pre><code>In Python,

```{code-cell} ipython3
ancestor = lambda ancestor, descendant: Relation('ancestor', (ancestor, descendant))

database = {
    parent("A", "B"), 
    parent("B", "C"), 
    parent("C", "D"), 
    parent("AA", "BB"),
    parent("BB", "CC")
}


X = Variable("X")
Y = Variable("Y")
Z = Variable("Z")
# ancestor(X, Y) :- parent(X, Y)
ancestor_rule_base = Rule(ancestor(X, Y), [parent(X, Y)])
# ancestor(X, Z) :- parent(X, Y), ancestor(Y, Z)
ancestor_rule_recursive = Rule(ancestor(X, Z), {parent(X, Y), ancestor(Y, Z)})

rules = [ancestor_rule_base, ancestor_rule_recursive]</code></pre>
<p>Alright, let’s dive into this. What is different from <code>run_logical_operator</code>? It’s the hierarchy or recursion. If you see it as hierarchy(I’m visualizing this as a tree), one has to keep on going until we reach the top of the tree.</p>
<p><img src="https://raw.githubusercontent.com/RAbraham/mercylog/master/book/teaching/img/ancestor-hierarchy.png" class="img-fluid"></p>
<p>So let’s imagine how we would process the above example. In the first pass, we would do the simplest inference from base fact to derived fact using the base rule of <code>ancestor(X, Y) :- parent(X, Y)</code>.</p>
<p>Showing one hierarchy as an example(starting from <code>A</code>).</p>
<p><img src="https://raw.githubusercontent.com/RAbraham/mercylog/master/book/teaching/img/iterative-ancestry-depth1.png" class="img-fluid"></p>
<pre><code>Pass 1: Base Facts and Inferred facts i.e. KnowledgeBase1
parent("A", "B"),
parent("B", "C"),
parent("C", "D"),
parent("AA", "BB"),
parent("BB", "CC")]
# ----------------- New inferred facts below --------------
ancestor("A", "B"),
ancestor("B", "C"),
ancestor("C", "D"),
ancestor("AA", "BB"),
ancestor("BB", "CC")</code></pre>
<p>Now that’s done, we can focus on inference from a combination of inferred facts and base facts to new inferred facts using the recursive rule <code>ancestor(X, Z) :- parent(X, Y), ancestor(Y, Z)</code>. For e.g.&nbsp;in <code>KnowledgeBase1</code>, we have <code>parent("C","D")</code> and <code>ancestor("B", "C")</code> , so we can infer the fact <code>ancestor("B", "D")</code> i.e grandparents. We keep on doing this till we get:</p>
<p><img src="https://raw.githubusercontent.com/RAbraham/mercylog/master/book/teaching/img/iterative-ancestry-depth2.png" class="img-fluid"></p>
<pre><code>Pass 2: KnowledgeBase2
parent("A", "B"),
parent("B", "C"),
parent("C", "D"),
parent("AA", "BB"),
parent("BB", "CC")
ancestor("A", "B"),
ancestor("B", "C"),
ancestor("C", "D"),
ancestor("AA", "BB"),
ancestor("BB", "CC")
# ----------------- New inferred facts below --------------
ancestor("A", "C")
ancestor("B", "D")
ancestor("AA", "CC")</code></pre>
<p>Do we stop? No, we have to keep on going till we find all the ancestors. Let’s apply the rules to <code>KnowledgeBase2</code> and get</p>
<p><img src="https://raw.githubusercontent.com/RAbraham/mercylog/master/book/teaching/img/iterative-ancestry-depth3.png" class="img-fluid"></p>
<pre><code>Pass 3: KnowledgeBase3
parent("A", "B"),
parent("B", "C"),
parent("C", "D"),
parent("AA", "BB"),
parent("BB", "CC")
ancestor("A", "B"),
ancestor("B", "C"),
ancestor("C", "D"),
ancestor("AA", "BB"),
ancestor("BB", "CC")
ancestor("A", "C")
ancestor("B", "D")
ancestor("AA", "CC")
# ----------------- New inferred facts below --------------
ancestor("A", "D")</code></pre>
<p>i.e <code>A</code> is the great grand parent of <code>D</code></p>
<p>Do we stop? Yes(if you look at the above example), but the computer does not know that. There could be new inferred facts, so let’s try again for <code>KnowledgeBase4</code>.</p>
<pre><code>Pass 4: KnowledgeBase4
parent("A", "B"),
parent("B", "C"),
parent("C", "D"),
parent("AA", "BB"),
parent("BB", "CC"),
ancestor("A", "B"),
ancestor("B", "C"),
ancestor("C", "D"),
ancestor("AA", "BB"),
ancestor("BB", "CC")
ancestor("A", "C")
ancestor("B", "D")
ancestor("AA", "CC")
ancestor("A", "D")
# ----------------- New inferred facts below --------------
No New Facts</code></pre>
<p>Aha! There are no more new inferred facts. If we do another pass on <code>KnowledgeBase4</code>, it would come out the same. So we can stop!</p>
<p>So the logic to stop would be: Take the output of each iteration. If it matches the input to that iteration, stop(as we did not learn any new inferred facts). If not a match, then run another iteration. Let’s call this method <code>iterate_until_no_change</code>.</p>
<p>```{code-cell} ipython3 def iterate_until_no_change(transform: Callable, initial_value: Set) -&gt; Set: a_input = initial_value</p>
<pre><code>while True:
    a_output = transform(a_input)
    if a_output == a_input:
        return a_output
    a_input = a_output</code></pre>
<pre><code>
Now, we already have `evaluate_logical_operators_in_rule`. That will be our `transform` function above. So putting this all together below.

```{code-cell} ipython3
def run_recursive(database: Set[Relation], rules: List[Rule], query: Relation):
    transformer = lambda a_knowledgebase: generate_knowledgebase(evaluate_logical_operators_in_rule, a_knowledgebase, rules)
    knowledgebase = iterate_until_no_change(transformer, database)
    return filter_facts(knowledgebase, query, query_variable_match)</code></pre>
<p>Let’s define the query</p>
<p>```{code-cell} ipython3 query = ancestor(X, Y)</p>
<p>recursive_result = run_recursive(database, rules, query)</p>
<p>expected_result = { ancestor(“A”, “B”), ancestor(“B”, “C”), ancestor(“C”, “D”), ancestor(“AA”, “BB”), ancestor(“BB”, “CC”), ancestor(“A”, “C”), ancestor(“B”, “D”), ancestor(“AA”, “CC”), ancestor(“A”, “D”) }</p>
<p>assert recursive_result == expected_result, f”{recursive_result} not equal to {expected_result}”</p>
<pre><code>
Let's explore other queries we can ask.
Is `AA` the ancestor of `C`?(No! Such an impolite question)

```{code-cell} ipython3
query = ancestor("AA", "C")

assert run_recursive(database, rules, query) == set()</code></pre>
<p>What if I want to find all ancestors of <code>C</code>?</p>
<p><code>{code-cell} ipython3 query = ancestor(X, "C") assert run_recursive(database, rules, query) == {ancestor("A", "C"), ancestor("B", "C")}</code></p>
<p>What if I want to find who all are the descendants of <code>AA</code>. Again, use the same query but just reverse the order!</p>
<p><code>{code-cell} ipython3 query = ancestor("AA", X) assert run_recursive(database, rules, query) == {ancestor("AA", "BB"), ancestor("AA", "CC")}</code></p>
<p>Finally, who are the intermediates between <code>A</code> and <code>D</code> i.e.&nbsp;<code>B</code> and <code>C</code>.</p>
<p><code>Z</code> is an intermediate of <code>X</code> and <code>Y</code> if <code>X</code> is it’s ancestor and <code>Y</code> is its descendant.</p>
<pre><code>intermediate(Z, X, Y) :- ancestor(X, Z), ancestor(Z, Y)</code></pre>
<p>In Python,</p>
<p>```{code-cell} ipython3 intermediate = lambda intermediate, start, end: Relation(“intermediate”, (intermediate, start, end)) intermediate_head = intermediate(Z, X, Y) intermediate_body = {ancestor(X, Z), ancestor(Z, Y)} intermediate_rule = Rule(intermediate_head, intermediate_body)</p>
<p>rules = [ancestor_rule_base, ancestor_rule_recursive, intermediate_rule] query = intermediate(Z, “A”, “D”)</p>
<p>assert run_recursive(database, rules, query) == {intermediate(“B”, “A”, “D”), intermediate(“C”, “A”, “D”)} ```</p>
<p>+++</p>
<p>That’s it! If you found it interesting, all these ideas will be explored in <a href="https://github.com/RAbraham/mercylog">Mercylog</a>, a soon to be built Datalog inspired library in Python.</p>
</section>
<section id="extra-extra.-read-all-about-it" class="level2">
<h2 class="anchored" data-anchor-id="extra-extra.-read-all-about-it">Extra Extra. Read All About It</h2>
<ul>
<li><p>This post was inspired by this <a href="https://dodisturb.me/posts/2018-12-25-The-Essence-of-Datalog.html">post</a>.</p></li>
<li><p>SQL does support <a href="https://dba.stackexchange.com/a/94944/146211">recursion</a>. I just find Datalog has a cleaner syntax.</p></li>
<li><p>One aspect of Datalog being declarative is that the order of rules does not matter either. So technically, instead of <code>rules = [rule1, rule2]</code>, we could have used <code>rules = frozenset([rule1, rule2])</code>. The latter is a bit more clutter so I used simple lists.</p></li>
</ul>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>