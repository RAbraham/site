[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "site",
    "section": "",
    "text": "Post With Code\n\n\n\n\n\n\n\nnews\n\n\ncode\n\n\nanalysis\n\n\n\n\n\n\n\n\n\n\n\nFeb 26, 2023\n\n\nHarlow Malloc\n\n\n\n\n\n\n  \n\n\n\n\nWelcome To My Blog\n\n\n\n\n\n\n\nnews\n\n\n\n\n\n\n\n\n\n\n\nFeb 23, 2023\n\n\nTristan O’Malley\n\n\n\n\n\n\n  \n\n\n\n\nTabbyQL. A visual query language for databases\n\n\n\n\n\n\n\nmarkdown\n\n\n\n\nDesign of TabbyQL. A visual alternative to SQL\n\n\n\n\n\n\nDec 13, 2021\n\n\n\n\n\n\n  \n\n\n\n\nA toy Datalog parser using Ohm and Glue.\n\n\n\n\n\n\n\nmarkdown\n\n\n\n\nA toy Datalog parser using Ohm parser and Glue.\n\n\n\n\n\n\nOct 29, 2021\n\n\n\n\n\n\n  \n\n\n\n\nFastpages Notebook Blog Post\n\n\n\n\n\n\n\njupyter\n\n\n\n\nA tutorial of fastpages for Jupyter notebooks.\n\n\n\n\n\n\nFeb 20, 2020\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIntroduction to Datalog(Bashlog) in Python.\n\n\n\n\n\n\n\nmarkdown\n\n\n\n\nDatalog is like SQL + Recursion. It’s derivatives have reduced the code base by 50% or more.\n\n\n\n\n\n\nFeb 16, 2020\n\n\n\n\n\n\n  \n\n\n\n\nAn Example Markdown Post by Rajiv\n\n\n\n\n\n\n\nmarkdown\n\n\n\n\nA minimal example of using markdown with fastpages.\n\n\n\n\n\n\nJan 14, 2020\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About me",
    "section": "",
    "text": "I don’t know how it came to me but it changed my life. I was in grad school and my coding style was “bang on the keyboard until it’s done”. Then I chanced upon Martin Fowler’s book on Refactoring. I did not know that there was ‘good’ code and ‘bad’ code. It was supposed to be just code!\nThat book started a journey where programming became a creative endeavour. I just had to write ‘good’ code. I’m still writing ‘bad’ code. I could give up but the search has improved me as a programmer. It’s the journey after all(something I still don’t want to believe in. There has to be a pot of gold at the end ;) )\nThis journey has brought me to declarative programming languages. I am now investigating Datalog as a programming language. Bloom, Differential Datalog, MLog all inspire me. Is there a common ground? Check out at Mercylog :)"
  },
  {
    "objectID": "posts/2020-02-20-test.html",
    "href": "posts/2020-02-20-test.html",
    "title": "Fastpages Notebook Blog Post",
    "section": "",
    "text": "This notebook is a demonstration of some of capabilities of fastpages with notebooks.\nWith fastpages you can save your jupyter notebooks into the _notebooks folder at the root of your repository, and they will be automatically be converted to Jekyll compliant blog posts!\n\n\nThe first cell in your Jupyter Notebook or markdown blog post contains front matter. Front matter is metadata that can turn on/off options in your Notebook. It is formatted like this:\n# \"My Title\"\n> \"Awesome summary\"\n\n- toc: true\n- branch: master\n- badges: true\n- comments: true\n- author: Hamel Husain & Jeremy Howard\n- categories: [fastpages, jupyter]\n\nSetting toc: true will automatically generate a table of contents\nSetting badges: true will automatically include GitHub and Google Colab links to your notebook.\nSetting comments: true will enable commenting on your blog post, powered by utterances.\n\nThe title and description need to be enclosed in double quotes only if they include special characters such as a colon. More details and options for front matter can be viewed on the front matter section of the README.\n\n\n\nA #hide comment at the top of any code cell will hide both the input and output of that cell in your blog post.\nA #hide_input comment at the top of any code cell will only hide the input of that cell.\n\n\nThe comment #hide_input was used to hide the code that produced this.\n\n\nput a #collapse-hide flag at the top of any cell if you want to hide that cell by default, but give the reader the option to show it:\n\n\nCode\nimport pandas as pd\nimport altair as alt\n\n\nput a #collapse-show flag at the top of any cell if you want to show that cell by default, but give the reader the option to hide it:\n\n\nCode\ncars = 'https://vega.github.io/vega-datasets/data/cars.json'\nmovies = 'https://vega.github.io/vega-datasets/data/movies.json'\nsp500 = 'https://vega.github.io/vega-datasets/data/sp500.csv'\nstocks = 'https://vega.github.io/vega-datasets/data/stocks.csv'\nflights = 'https://vega.github.io/vega-datasets/data/flights-5k.json'\n\n\nplace a #collapse-output flag at the top of any cell if you want to put the output under a collapsable element that is closed by default, but give the reader the option to open it:\n\n#collapse-output\nprint('The comment #collapse-output was used to collapse the output of this cell by default but you can expand it.')\n\nThe comment #collapse-output was used to collapse the output of this cell by default but you can expand it.\n\n\n\n\n\nCharts made with Altair remain interactive. Example charts taken from this repo, specifically this notebook.\n\n\n\n# single-value selection over [Major_Genre, MPAA_Rating] pairs\n# use specific hard-wired values as the initial selected values\nselection = alt.selection_single(\n    name='Select',\n    fields=['Major_Genre', 'MPAA_Rating'],\n    init={'Major_Genre': 'Drama', 'MPAA_Rating': 'R'},\n    bind={'Major_Genre': alt.binding_select(options=genres), 'MPAA_Rating': alt.binding_radio(options=mpaa)}\n)\n  \n# scatter plot, modify opacity based on selection\nalt.Chart(df).mark_circle().add_selection(\n    selection\n).encode(\n    x='Rotten_Tomatoes_Rating:Q',\n    y='IMDB_Rating:Q',\n    tooltip='Title:N',\n    opacity=alt.condition(selection, alt.value(0.75), alt.value(0.05))\n)\n\n\n\n\n\n\n\n\n\n\n\nalt.Chart(df).mark_circle().add_selection(\n    alt.selection_interval(bind='scales', encodings=['x'])\n).encode(\n    alt.X('Rotten_Tomatoes_Rating', type='quantitative'),\n    alt.Y('IMDB_Rating', type='quantitative', axis=alt.Axis(minExtent=30)),\n#     y=alt.Y('IMDB_Rating:Q', ), # use min extent to stabilize axis title placement\n    tooltip=['Title:N', 'Release_Date:N', 'IMDB_Rating:Q', 'Rotten_Tomatoes_Rating:Q']\n).properties(\n    width=500,\n    height=400\n)\n\n\n\n\n\n\n\n\n\n\n\n# select a point for which to provide details-on-demand\nlabel = alt.selection_single(\n    encodings=['x'], # limit selection to x-axis value\n    on='mouseover',  # select on mouseover events\n    nearest=True,    # select data point nearest the cursor\n    empty='none'     # empty selection includes no data points\n)\n\n# define our base line chart of stock prices\nbase = alt.Chart().mark_line().encode(\n    alt.X('date:T'),\n    alt.Y('price:Q', scale=alt.Scale(type='log')),\n    alt.Color('symbol:N')\n)\n\nalt.layer(\n    base, # base line chart\n    \n    # add a rule mark to serve as a guide line\n    alt.Chart().mark_rule(color='#aaa').encode(\n        x='date:T'\n    ).transform_filter(label),\n    \n    # add circle marks for selected time points, hide unselected points\n    base.mark_circle().encode(\n        opacity=alt.condition(label, alt.value(1), alt.value(0))\n    ).add_selection(label),\n\n    # add white stroked text to provide a legible background for labels\n    base.mark_text(align='left', dx=5, dy=-5, stroke='white', strokeWidth=2).encode(\n        text='price:Q'\n    ).transform_filter(label),\n\n    # add text labels for stock prices\n    base.mark_text(align='left', dx=5, dy=-5).encode(\n        text='price:Q'\n    ).transform_filter(label),\n    \n    data=stocks\n).properties(\n    width=500,\n    height=400\n)\n\n\n\n\n\n\n\n\n\n\nYou can display tables per the usual way in your blog:\n\n# display table with pandas\ndf[['Title', 'Worldwide_Gross', \n    'Production_Budget', 'Distributor', 'MPAA_Rating', 'IMDB_Rating', 'Rotten_Tomatoes_Rating']].head()\n\n\n\n\n\n  \n    \n      \n      Title\n      Worldwide_Gross\n      Production_Budget\n      Distributor\n      MPAA_Rating\n      IMDB_Rating\n      Rotten_Tomatoes_Rating\n    \n  \n  \n    \n      0\n      The Land Girls\n      146083.0\n      8000000.0\n      Gramercy\n      R\n      6.1\n      NaN\n    \n    \n      1\n      First Love, Last Rites\n      10876.0\n      300000.0\n      Strand\n      R\n      6.9\n      NaN\n    \n    \n      2\n      I Married a Strange Person\n      203134.0\n      250000.0\n      Lionsgate\n      None\n      6.8\n      NaN\n    \n    \n      3\n      Let's Talk About Sex\n      373615.0\n      300000.0\n      Fine Line\n      None\n      NaN\n      13.0\n    \n    \n      4\n      Slam\n      1087521.0\n      1000000.0\n      Trimark\n      R\n      3.4\n      62.0\n    \n  \n\n\n\n\n\n\n\n\n\nYou can reference local images and they will be copied and rendered on your blog automatically. You can include these with the following markdown syntax:\n![](my_icons/fastai_logo.png)\n\n\n\n\nRemote images can be included with the following markdown syntax:\n![](https://image.flaticon.com/icons/svg/36/36686.svg)\n\n\n\n\nAnimated Gifs work, too!\n![](https://upload.wikimedia.org/wikipedia/commons/7/71/ChessPawnSpecialMoves.gif)\n\n\n\n\nYou can include captions with markdown images like this:\n![](https://www.fast.ai/images/fastai_paper/show_batch.png \"Credit: https://www.fast.ai/2020/02/13/fastai-A-Layered-API-for-Deep-Learning/\")"
  },
  {
    "objectID": "posts/2020-02-20-test.html#github-flavored-emojis",
    "href": "posts/2020-02-20-test.html#github-flavored-emojis",
    "title": "Fastpages Notebook Blog Post",
    "section": "GitHub Flavored Emojis",
    "text": "GitHub Flavored Emojis\nTyping I give this post two :+1:! will render this:\nI give this post two :+1:!"
  },
  {
    "objectID": "posts/2020-02-20-test.html#tweetcards",
    "href": "posts/2020-02-20-test.html#tweetcards",
    "title": "Fastpages Notebook Blog Post",
    "section": "Tweetcards",
    "text": "Tweetcards\nTyping > twitter: https://twitter.com/jakevdp/status/1204765621767901185?s=20 will render this:\n\ntwitter: https://twitter.com/jakevdp/status/1204765621767901185?s=20"
  },
  {
    "objectID": "posts/2020-02-20-test.html#youtube-videos",
    "href": "posts/2020-02-20-test.html#youtube-videos",
    "title": "Fastpages Notebook Blog Post",
    "section": "Youtube Videos",
    "text": "Youtube Videos\nTyping > youtube: https://youtu.be/XfoYk_Z5AkI will render this:"
  },
  {
    "objectID": "posts/2020-02-20-test.html#boxes-callouts",
    "href": "posts/2020-02-20-test.html#boxes-callouts",
    "title": "Fastpages Notebook Blog Post",
    "section": "Boxes / Callouts",
    "text": "Boxes / Callouts\nTyping > Warning: There will be no second warning! will render this:\n\n\n\n\n\n\nWarning\n\n\n\nThere will be no second warning!\n\n\nTyping > Important: Pay attention! It's important. will render this:\n\n\n\n\n\n\nImportant\n\n\n\nPay attention! It’s important.\n\n\nTyping > Tip: This is my tip. will render this:\n\n\n\n\n\n\nTip\n\n\n\nThis is my tip.\n\n\nTyping > Note: Take note of this. will render this:\n\n\n\n\n\n\nNote\n\n\n\nTake note of this.\n\n\nTyping > Note: A doc link to [an example website: fast.ai](https://www.fast.ai/) should also work fine. will render in the docs:\n\n\n\n\n\n\nNote\n\n\n\nA doc link to an example website: fast.ai should also work fine."
  },
  {
    "objectID": "posts/2020-02-20-test.html#footnotes",
    "href": "posts/2020-02-20-test.html#footnotes",
    "title": "Fastpages Notebook Blog Post",
    "section": "Footnotes",
    "text": "Footnotes\nYou can have footnotes in notebooks, however the syntax is different compared to markdown documents. This guide provides more detail about this syntax, which looks like this:\n{% raw %}For example, here is a footnote {% fn 1 %}.\nAnd another {% fn 2 %}\n{{ 'This is the footnote.' | fndetail: 1 }}\n{{ 'This is the other footnote. You can even have a [link](www.github.com)!' | fndetail: 2 }}{% endraw %}\nFor example, here is a footnote {% fn 1 %}.\nAnd another {% fn 2 %}\n{{ ‘This is the footnote.’ | fndetail: 1 }} {{ ‘This is the other footnote. You can even have a link!’ | fndetail: 2 }}"
  },
  {
    "objectID": "posts/2020-01-14-test-markdown-post.html",
    "href": "posts/2020-01-14-test-markdown-post.html",
    "title": "An Example Markdown Post by Rajiv",
    "section": "",
    "text": "Jekyll requires blog post files to be named according to the following format:\nYEAR-MONTH-DAY-filename.md\nWhere YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files.\nThe first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above.\n\n\n\nYou can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule:\n\n\n\n\nHere’s a list:\n\nitem 1\nitem 2\n\nAnd a numbered list:\n\nitem 1\nitem 2\n\n\n\n\n\nThis is a quotation\n\n{% include alert.html text=“You can include alert boxes” %}\n…and…\n{% include info.html text=“You can include info boxes” %}\n\n\n\n\n\n\n\nYou can format text and code per usual\nGeneral preformatted text:\n# Do a thing\ndo_thing()\nPython code and output:\n# Prints '2'\nprint(1+1)\n2\nFormatting text as shell commands:\necho \"hello world\"\n./some_script.sh --option \"value\"\nwget https://example.com/cat_photo1.png\nFormatting text as YAML:\nkey: value\n- another_key: \"another value\"\n\n\n\n\n\n\nColumn 1\nColumn 2\n\n\n\n\nA thing\nAnother thing\n\n\n\n\n\n\n{% twitter https://twitter.com/jakevdp/status/1204765621767901185?s=20 %}"
  },
  {
    "objectID": "posts/2021-12-13-tabbyql-design.html",
    "href": "posts/2021-12-13-tabbyql-design.html",
    "title": "TabbyQL. A visual query language for databases",
    "section": "",
    "text": "Objective\nThis post is to present, for feedback, an alternative to SQL: TabbyQL, a visual dataflow query language.\n\n\nMotivation\n(ask me and I’ll write something up)\n\n\nDesign"
  },
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Welcome To My Blog",
    "section": "",
    "text": "This is the first post in a Quarto blog. Welcome!\n\nSince this post doesn’t specify an explicit image, the first image in the post will be used in the listing page of posts."
  },
  {
    "objectID": "posts/post-with-code/index.html",
    "href": "posts/post-with-code/index.html",
    "title": "Post With Code",
    "section": "",
    "text": "This is a post with executable code."
  },
  {
    "objectID": "posts/2021-10-29-dsl-datalog-ohm-glue.html",
    "href": "posts/2021-10-29-dsl-datalog-ohm-glue.html",
    "title": "A toy Datalog parser using Ohm and Glue.",
    "section": "",
    "text": "This post shows you how to create a toy Datalog, a laughably incomplete subset of the Datalog language, using an Ohm parser for the syntax and a Glue parser for the semantics. The final output is a Python program."
  },
  {
    "objectID": "posts/2021-10-29-dsl-datalog-ohm-glue.html#creating-a-parse-tree",
    "href": "posts/2021-10-29-dsl-datalog-ohm-glue.html#creating-a-parse-tree",
    "title": "A toy Datalog parser using Ohm and Glue.",
    "section": "Creating a Parse Tree",
    "text": "Creating a Parse Tree\nAlright, time to dive in. We build the grammar for our toy Datalog. Ohm has an excellent grammar editor which allows one to write a grammar, test it with examples and see the ‘concrete syntax tree’ i.e. how a concrete example of Datalog code breaks out into a parse tree.\n\n\n\nOhm Editor\n\n\nLet’s start with the smallest Ohm grammar\ndatalog {\n Program = Statement+\n}\nThis is just saying that my Datalog code is a Program with one or more Statements. The + indicates one or more.\nWhat’s a Statement? Well, in the simplest case, we have a fact, e.g. parent(abe, bob). and then we have a rule e.g. father (X, Y) :- man(X), parent(X, Y).. I see a sub pattern there as relation (Variable1, Variable2). I’ll call this a Clause and then I’ll worry later how to parse it. So the rule becomes Clause :- Clause, Clause. or even Clause :- Clause, Clause, Clause... We have to capture the pattern , Clause 0 or many times. The way we do it in Ohm is like this.\nStatement =\n    Clause \".\"                          -- fact\n  | Clause \":-\" Clause CommaClause* \".\" -- rule\n\nCommaClause = \",\" Clause\n-- fact and -- rule look like comments but they are more than that. I’ll explain later below.\nCool, what’s a Clause? It’s like relation(Variable1, Variable2,..,VariableN). I’m going to worry about the ‘variable’ number of variables later. For now, I’ll call it\nClause = Relation \"(\" IDList \")\"\nOk, What’s a Relation? It’s a lower case string e.g. father and it has to start with a lower case letter(a Datalog convention). We need to capture single letter relations e.g a in a(X,Y) or bigger relations e.g. father\nRelation = LowerCaseIdent\nLowerCaseIdent = \"a\" .. \"z\" identRest*\nidentRest = \"0-9\" | \"_\" | \"A\" .. \"Z\" | \"a\" .. \"z\"\nidentRest captures the pattern that the rest of the identifier can can either be a number, underscore or upper case or lower case letters.\nNow, IDList. You’ll notice a trend here with CommaClause and IDList. It has the same feeling like designing functions. Often, I’ll write pseudocode on how I want a function to look and I’ll design the subroutines without actually implementing them. Just the subroutine calls. Once I like what I see, I’ll then go ahead and implement each subroutine. It feels similar here.\nIDList has the same feel like Clause, doesn’t it?\nIDList = ID CommaID*\nCommaID = \",\" ID\nAn ID is going to be either a literal(or constant) like abe in man(abe) or a variable like X and Y in father(X, Y). A variable starts with a capital letter as per Datalog convention.\n\nID = Variable | Literal\nVariable = CapitalizedIdent\nLiteral = LowerCaseIdent \n#LowerCaseIdent  and identRest were already explained before\nCapitalizedIdent = \"A\" .. \"Z\" identRest*\n\nSo there you go, I think that’s it. Let’s see the whole ohm grammar file.\ndatalog {\nProgram = Statement+\nStatement =\n    Clause \".\"                          -- fact\n  | Clause \":-\" Clause CommaClause* \".\" -- rule\n\nClause = Relation \"(\" IDList \")\"\nCommaClause = \",\" Clause\n\nRelation = LowerCaseIdent\nIDList = ID CommaID*\nID = Variable | Literal\nCommaID = \",\" ID\n\nVariable = CapitalizedIdent\nLiteral = LowerCaseIdent\n\nLowerCaseIdent = \"a\" .. \"z\" identRest*\nCapitalizedIdent = \"A\" .. \"Z\" identRest*\n\nidentRest = \"0-9\" | \"_\" | \"A\" .. \"Z\" | \"a\" .. \"z\"\n}"
  },
  {
    "objectID": "posts/2021-10-29-dsl-datalog-ohm-glue.html#glue",
    "href": "posts/2021-10-29-dsl-datalog-ohm-glue.html#glue",
    "title": "A toy Datalog parser using Ohm and Glue.",
    "section": "Glue",
    "text": "Glue\nNow that we have the Ohm grammar, it’s time to use it to assign some meaning to the parse tree that it’ll generate from our sample Datalog program. Ohm actually already allows us to do that too.\nHowever, Paul Tarvydas found that he was writing a lot of boilerplate code and decided to ….. write another DSL for it! It’s called Glue.\nCAUTION: Glue is a prototype and does not cover all edge cases.\nThe way Glue works is you take all the symbols in your Ohm grammar e.g. Clause, ID and write a corresponding piece of JavaScript code to be generated. Glue also simplifies it in the way that you can just write the string of code(Python in my case) that you want to generate. Let’s start with a dummy example.\nProgram [@Statement] = [[ ${Statement} ]]\nHere, Program and Statement are from the Ohm grammar above. Since we have multiple statements, we use @ to indicate that. The code to be generated is between [[ and ]]. And we refer to the code with JavaScript interpolation code ${}. What is the value of Statement above? Well, it’ll be populated ‘somehow’ by Ohm with the values from the rest of the grammar.\nI think the above example was too easy for you :) . Let’s show you what I have to actually do.\nIf you look at my required Python Mercylog code above, I need to first generate some generic, wrapper like Python code like mercylog import statements and initialization no matter what the Datalog code is to be generated.\n\nfrom mercylog import R, V, and_, db\nfb = [ .. statements ..] # refer to facts_rules_query above \nds = db() \nresult = ds(fb)\nprint(result.df()) \nThe way we specify that in Glue is:\nProgram [@Statement] = [[from mercylog import R, V, and_, db\\nfb = \\[ ${Statement}\\] \\nds = db() \\nresult = ds(fb) \\nprint(result.df()) ]]\nIt may not look very clean and Paul may have some way to improve on this but I just wanted to give you an idea.\nWe need to escape special characters in Glue. For e.g., I have to use [] for Python but that means something in Glue too so I have to escape it e.g. \\[\nWhere do we get statements from? Well, there was something I didn’t mention before, that it’s time to talk about now. Notice the -- rule and -- fact in our Ohm grammar?\nStatement =\n    Clause \".\"                          -- fact\n  | Clause \":-\" Clause CommaClause* \".\" -- rule\n\nThey look like comments but they are called case labels in Ohm. They are a way to specify different execution paths for Glue (actually, for Ohm, which Glue uses underneath). So we have two entries in Glue for Statement, Statement_fact and Statement_rule\nNote, that the number of parameters for e.g. Statement_fact match closely with how it’s grammar is specified. Using k in kperiod is just a convention, I think, to indicate that it’s a literal unlike the others.\nIf it’s a fact, I just have to add it to the list fb. The code containing fb is generated above for Program  [@statement]. So I take clause which will be generated later and just add a , to it, as I’m adding it to a Python list which wants a comma between list elements. For rules, I have to convert Statement_rule to the corresponding mercylog  statement i.e. clause1 << and_(...)\nStatement_fact [clause kperiod] = [[${clause},\\n]]\nStatement_rule [clause1 kcolondash clause @commaclause kdot] = [[${clause1} << and_(${clause}${commaclause}),\\n]]\n\nI think the rest of the code follows the same principles explained above.\nHere’s the final Glue Code.\nProgram [@Statement] = [[from mercylog import R, V, and_, db\\nfb = \\[ ${Statement}\\] \\nds = db() \\nresult = ds(fb) \\nprint(result.df()) ]]\nStatement_fact [clause kperiod] = [[${clause},\\n]]\nStatement_rule [clause1 kcolondash clause @commaclause kdot] = [[${clause1} << and_(${clause}${commaclause}),\\n]]\n\nClause [predicate klpar idlist krpar] = [[${predicate}(${idlist})]]\n\nCommaClause [kcomma clause] = [[\\,${clause}]]\n\nRelation [lowercaseident] = [[R.${lowercaseident}]]\nIDList [id @commaid] = [[${id}${commaid}]]\n\nID [id] = [[${id}]]\nCommaID [kcomma id] = [[\\, ${id}]]\n\nVariable [capident] = [[V.${capident}]]\nLiteral [lowercaseident] = [[\"${lowercaseident}\"]]\n\nLowerCaseIdent [c @cs] = [[${c}${cs}]]\n\nCapitalizedIdent [c @cs] = [[${c}${cs}]]\n\nidentRest [c] = [[${c}]]"
  },
  {
    "objectID": "posts/2021-10-29-dsl-datalog-ohm-glue.html#code-generation",
    "href": "posts/2021-10-29-dsl-datalog-ohm-glue.html#code-generation",
    "title": "A toy Datalog parser using Ohm and Glue.",
    "section": "Code Generation",
    "text": "Code Generation\nSo we have the Ohm and Glue grammars. We can now take a Datalog program and generate Python code. Using the pfr tool in the repo parse tool which reads an Ohm, Glue file and input source language file, we can generate the Python code.\npfr test.datalog datalog.ohm mercylog.glue > test.py \n\nNOTE: I had to hack the code above a bit to make it work for me but Paul may have updated his repo to make it work seamlessly for all. The emphasis here is not on having production ready tools but to rapidly explore ideas in DSL building and get feedback.\nThat generates\nfrom mercylog import R, V, and_, db\nfb = [ R.parent(\"abe\", \"bob\"),\nR.parent(\"abby\", \"bob\"),\nR.parent(\"bob\", \"carl\"),\nR.parent(\"bob\", \"connor\"),\nR.parent(\"beatrice\", \"carl\"),\nR.man(\"abe\"),\nR.man(\"bob\"),\nR.woman(\"abby\"),\nR.woman(\"beatrice\"),\nR.father(V.X, V.Y) << and_(R.man(V.X),R.parent(V.X, V.Y)),\nR.father(V.X, V.Y),\n] \nds = db() \nresult = ds(fb) \nprint(result.df()) \nNot that it’s not indented properly, nor have I done any optimizations. For e.g. V.X could be refactored to X=V.X like in the Python code showed in the very beginning. But that’s another exercise.\nNow to test my code, I have to create a project with mercylog in my dependencies and then do\npython test.py\n\nand I’ll see\n      Y    X\n0  connor  bob\n1     bob  abe\n2    carl  bob"
  },
  {
    "objectID": "posts/2020-02-16-introducing-mercylog.html",
    "href": "posts/2020-02-16-introducing-mercylog.html",
    "title": "Introduction to Datalog(Bashlog) in Python.",
    "section": "",
    "text": "TLDR:\nDatalog is like SQL + Recursion. It’s derivatives have reduced the code base by 50% or more.\n\n\nDatalog\nToday, I would like to explore a constrained language called Datalog. It’s a constrained form of Prolog and may not be as expressive as C++ or Python. But it’s derivatives have been known to reduce the numbers of lines of code down by 50% or more(Overlog, Yedalog).\nLet’s get started:\nDatalog has a minimalist syntax which I love. Let’s take an example. Suppose our data is about fathers and sons, mothers and daughters. If we had an excel sheet, we would enter the data like:\nFather  Son\nAks     Bob\nBob     Cad\nYan     Zer\nand another excel sheet for mothers and daughters:\nMother  Daughter\nMary    Marla\nMarla   Kay\nJane    Zanu\nIn Datalog, we express the same data as(together):\nfather('Aks', 'Bob')\nfather('Bob', 'Cad')\nfather('Yan', 'Zer')\nmother('Mary', 'Marla')\nmother('Marla', 'Kay')\nmother('Jane', 'Zanu')\nHere we are trying to say Aks is the father of ‘Bob’ and ‘Bob’ is the father of ‘Cad’. The datum father(‘Aks’, ‘Bob’) is called a fact i.e. it is true.\nSo Datalog can be used to express data. Not very interesting so far but a building block. These facts above can also be viewed as the existing state of the system, like we store state in files, or databases.\nBut that’s not enough. What about code? For Datalog, code are specified as rules to be applied declaratively.\nLet’s say our program needs to find out who’s a grandfather. We could write a rule like: ‘A person X is the grandfather of Z if X is the father of Y and Y is the father of Z’. In Datalog, this rule is written as:\ngrandfather(X, Z) :- father(X,Y), father(Y, Z)\nThe LHS (i.e. grandfather) is known as the head and the RHS after the :- is known as the body\nX, Y, Z are special variables called logic variables. They are different from regular variables. They are more used to represent a pattern or to link the head and the body.\nTo further understand logical variables, consider these two rules:\ngrandfather(X, Z) :- father(X,Y), father(Y, Z)\ngrandmother(X, Z) :- mother(X,Y), mother(Y, Z)\nHere the X, Z and Y used in grandfather are completely different from the X, Y and Z in grandmother. In rules, the variables only make sense in that single rule. So we can reuse the same logic variables in different rules without worrying that they have some logical connection.\nThe next concept is queries. How do we feed input and get back some output. Queries are similar to rules but without a head.\nfather(X, 'Aks'), mother(Z, 'Aks')\n \nwe mean, find the mother and father of ‘Aks’ or\nfather(X, 'Raj'), mother(Z, 'Raj')\nwe mean, find the father and mother of ‘Raj’\nSuppose, we want to say find the mother and father of all the children in the database, we make the query\nfather(X, Y), mother(Z, Y) \nDatalog will link Y for all mother and father facts and find the mothers and fathers for a child. It will not mix up fathers and mothers :)\nNow, If you opened a datalog interpreter and fed the above and made the following queries, you would get the results shown after the # sign\nfather(X,_) # ['Aks', 'Bob', 'Yan']\nfather(_,X) # ['Bob', 'Cad', 'Zer']\nfather(X, Y) # [('Aks', 'Bob'), ('Bob', 'Cad'), ('Yan', 'Zer')\nfather(X, 'Zer'), father('Zer', Y) # [] as there are no facts that match the query\ngrandfather(X, Y) # [('Aks', 'Cad')]\ngrandfather(X,_) # ['Aks']\nHere ’_’ is a special variable indicating that you don’t care for the result.\nI was always interested in the Datalog syntax and it’s power. I kept delaying it until I met Bashlog. Because, the syntax of datalog is so simple, it makes it easy to write interpeters for different targets. What Bashlog did was take Datalog syntax and convert it to bash scripts! Because, it used awk(mawk actually), sed, grep, which are tuned for high performance on Unix like platforms, it was incredibly fast in parsing big text files, comparable with all the specialized databases out there. Just Bash Scripts. It blew my mind. So if you are interested in pure Datalog, check out Bashlog\nWith Bashlog, you can run any bash like command and read that using Bashlog. Imagine there was a file(‘~/data.tsv’) with tab separated values of\nAks Bob\nBob Cad\nYan Zer\nWe could read that data like:\nfacts(F, S) :~ cat ~/data.tsv\nfather(X, Y) :- facts(X, Y)\nAnd then we proceed the same manner like before. What’s awesome is that you can run any Unix command(e.g. ls -l) as long as it returns an output of tab separated values.\nBut I wanted to use Datalog in my day to day programming. I wanted to see if I could use and leverage Datalog along with Python. Some benefits of Datalog in Python are:\n\nModularity. How do we abstract out patterns in our rules and facts.\nPossible access to exisitng rich source of libraries.\n\nSo I built Mercylog in Python.\nSo let’s translate the above rules to Mercylog syntax.\n\n\nInstallation\nIf you are using the Bashlog variant, - then you need Java 8 already installed\ngit clone https://github.com/RAbraham/mercylog_tutorial.git\ncd mercylog_tutorial\npython3 -m venv venv\nsource venv/bin/activate\npip install -r requirements.txt\npython tutorial.py\nThat should print\n['Aks']\n['Mary']\nRead below on the explanation and make tweaks if you want and run python tutorial.py again.\n\n\nUsage\nimport mercylog\nm = mercylog.BashlogV1()\n\n# father('Aks', 'Bob')\n# father('Bob', 'Cad')\n# father('Yan', 'Zer')\n# mother('Mary', 'Marla')\n# mother('Marla', 'Kay')\n# mother('Jane', 'Zanu')\n\nfather = m.relation('father')\nmother = m.relation('mother')\nfacts = [\n    father('Aks', 'Bob'),\n    father('Bob', 'Cad'),\n    father('Yan', 'Zer'),\n    mother('Mary', 'Marla'),\n    mother('Marla', 'Kay'),\n    mother('Jane', 'Zanu'),\n] \n# grandfather(X, Z) :- father(X,Y), father(Y, Z)\ngrandfather = m.relation('grandfather')\nX, Y, Z = m.variables('X', 'Y', 'Z') \ngrandfather(X, Z) <= [father(X, Y), father(Y, Z)]\nWhile in Datalog, you don’t have to explicitly state the variables and the relation, as it is baked in to the language, in our library in Python, we need to (e.g. X, Y, Z and father, grandfather)\nMaking a query in python has the following syntax\nm.run(facts, rules, query)\nA concrete example would be:\nm.run(facts, rules, grandfather(X, Y)) # which gives [('Aks', 'Cad')]\nm.run(facts, rules, father(X,_)) # ['Aks', 'Bob', 'Yan']\nm.run(facts, rules,father(_,X)) # ['Bob', 'Cad', 'Zer']\nm.run(facts, rules,father(X, Y)) # [('Aks', 'Bob'), ('Bob', 'Cad'), ('Yan', 'Zer')\nm.run(facts, rules, granfather(X,_)) # ['Aks']\nCreating this DSL in python gives us some unique benefits. For e.g if we had these two relations\npaternal_grandfather = m.relation('paternal_grandfather')\nmaternal_grandmother = m.relation('maternal_grandmother')\nfather = m.relation('father')\nmother = m.relation('mother')\n\nX, Y, Z = m.variables('X', 'Y', 'Z')\nrules = [\n    paternal_grandfather(X, Z) <= [father(X, Y), father(Y, Z)],\n    maternal_grandmother(X, Z) <= [mother(X, Y), mother(Y, Z)]\n] \nIf you notice, the rule for paternal_grandfather and maternal_grandmother are very similar. I could perhaps encapsulate that into a function. I’ll use the word transitive though I believe it is incorrect to use it.. but I don’t know what to call this for now. Rewriting the above code:\n\ndef transitive(head, clause):\n    X, Y, Z = m.variables('X', 'Y', 'Z')\n    return head(X, Z) <= [clause(X, Y), clause(Y, Z)]\n\npaternal_grandfather = m.relation('paternal_grandfather')\nmaternal_grandmother = m.relation('maternal_grandmother')\nfather = m.relation('father')\nmother = m.relation('mother')\n\n\nrules = [\n    transitive(paternal_grandfather, father),\n    transitive(maternal_grandmother, mother)\n]     \nIn this way, using Python, we have modularized a pattern using the transitive function.\nLet’s recap the benefits of Mercylog - Simple Syntax. All you need to know is facts and rules. Because of such simplicity, it is also easy to build compilers for it. - Expressive. Rules give a powerful mechanism - Declarative. Like SQL but more expressive. So we can optimize it’s engines without affecting the code\nI’ll continue to update you with my future learnings!"
  }
]