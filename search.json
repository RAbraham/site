[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "site",
    "section": "",
    "text": "TabbyQL. A visual query language for databases\n\n\n\n\n\n\n\nmarkdown\n\n\n\n\nDesign of TabbyQL. A visual alternative to SQL\n\n\n\n\n\n\nDec 13, 2021\n\n\n\n\n\n\n  \n\n\n\n\nA toy Datalog parser using Ohm and Glue.\n\n\n\n\n\n\n\nmarkdown\n\n\n\n\nA toy Datalog parser using Ohm parser and Glue.\n\n\n\n\n\n\nOct 29, 2021\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIntroduction to Datalog(Bashlog) in Python.\n\n\n\n\n\n\n\nmarkdown\n\n\n\n\nDatalog is like SQL + Recursion. It’s derivatives have reduced the code base by 50% or more.\n\n\n\n\n\n\nFeb 16, 2020\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About me",
    "section": "",
    "text": "I don’t know how it came to me but it changed my life. I was in grad school and my coding style was “bang on the keyboard until it’s done”. Then I chanced upon Martin Fowler’s book on Refactoring. I did not know that there was ‘good’ code and ‘bad’ code. It was supposed to be just code!\nThat book started a journey where programming became a creative endeavour. I just had to write ‘good’ code. I’m still writing ‘bad’ code. I could give up but the search has improved me as a programmer. It’s the journey after all(something I still don’t want to believe in. There has to be a pot of gold at the end ;) )\nThis journey has brought me to declarative programming languages. I am now investigating Datalog as a programming language. Bloom, Differential Datalog, MLog all inspire me. Is there a common ground? Check out at Mercylog :)"
  },
  {
    "objectID": "posts/2021-12-13-tabbyql-design.html",
    "href": "posts/2021-12-13-tabbyql-design.html",
    "title": "TabbyQL. A visual query language for databases",
    "section": "",
    "text": "Objective\nThis post is to present, for feedback, an alternative to SQL: TabbyQL, a visual dataflow query language.\n\n\nMotivation\n(ask me and I’ll write something up)\n\n\nDesign"
  },
  {
    "objectID": "posts/2021-10-29-dsl-datalog-ohm-glue.html",
    "href": "posts/2021-10-29-dsl-datalog-ohm-glue.html",
    "title": "A toy Datalog parser using Ohm and Glue.",
    "section": "",
    "text": "This post shows you how to create a toy Datalog, a laughably incomplete subset of the Datalog language, using an Ohm parser for the syntax and a Glue parser for the semantics. The final output is a Python program."
  },
  {
    "objectID": "posts/2021-10-29-dsl-datalog-ohm-glue.html#creating-a-parse-tree",
    "href": "posts/2021-10-29-dsl-datalog-ohm-glue.html#creating-a-parse-tree",
    "title": "A toy Datalog parser using Ohm and Glue.",
    "section": "Creating a Parse Tree",
    "text": "Creating a Parse Tree\nAlright, time to dive in. We build the grammar for our toy Datalog. Ohm has an excellent grammar editor which allows one to write a grammar, test it with examples and see the ‘concrete syntax tree’ i.e. how a concrete example of Datalog code breaks out into a parse tree.\n\n\n\nOhm Editor\n\n\nLet’s start with the smallest Ohm grammar\ndatalog {\n Program = Statement+\n}\nThis is just saying that my Datalog code is a Program with one or more Statements. The + indicates one or more.\nWhat’s a Statement? Well, in the simplest case, we have a fact, e.g. parent(abe, bob). and then we have a rule e.g. father (X, Y) :- man(X), parent(X, Y).. I see a sub pattern there as relation (Variable1, Variable2). I’ll call this a Clause and then I’ll worry later how to parse it. So the rule becomes Clause :- Clause, Clause. or even Clause :- Clause, Clause, Clause... We have to capture the pattern , Clause 0 or many times. The way we do it in Ohm is like this.\nStatement =\n    Clause \".\"                          -- fact\n  | Clause \":-\" Clause CommaClause* \".\" -- rule\n\nCommaClause = \",\" Clause\n-- fact and -- rule look like comments but they are more than that. I’ll explain later below.\nCool, what’s a Clause? It’s like relation(Variable1, Variable2,..,VariableN). I’m going to worry about the ‘variable’ number of variables later. For now, I’ll call it\nClause = Relation \"(\" IDList \")\"\nOk, What’s a Relation? It’s a lower case string e.g. father and it has to start with a lower case letter(a Datalog convention). We need to capture single letter relations e.g a in a(X,Y) or bigger relations e.g. father\nRelation = LowerCaseIdent\nLowerCaseIdent = \"a\" .. \"z\" identRest*\nidentRest = \"0-9\" | \"_\" | \"A\" .. \"Z\" | \"a\" .. \"z\"\nidentRest captures the pattern that the rest of the identifier can can either be a number, underscore or upper case or lower case letters.\nNow, IDList. You’ll notice a trend here with CommaClause and IDList. It has the same feeling like designing functions. Often, I’ll write pseudocode on how I want a function to look and I’ll design the subroutines without actually implementing them. Just the subroutine calls. Once I like what I see, I’ll then go ahead and implement each subroutine. It feels similar here.\nIDList has the same feel like Clause, doesn’t it?\nIDList = ID CommaID*\nCommaID = \",\" ID\nAn ID is going to be either a literal(or constant) like abe in man(abe) or a variable like X and Y in father(X, Y). A variable starts with a capital letter as per Datalog convention.\n\nID = Variable | Literal\nVariable = CapitalizedIdent\nLiteral = LowerCaseIdent \n#LowerCaseIdent  and identRest were already explained before\nCapitalizedIdent = \"A\" .. \"Z\" identRest*\n\nSo there you go, I think that’s it. Let’s see the whole ohm grammar file.\ndatalog {\nProgram = Statement+\nStatement =\n    Clause \".\"                          -- fact\n  | Clause \":-\" Clause CommaClause* \".\" -- rule\n\nClause = Relation \"(\" IDList \")\"\nCommaClause = \",\" Clause\n\nRelation = LowerCaseIdent\nIDList = ID CommaID*\nID = Variable | Literal\nCommaID = \",\" ID\n\nVariable = CapitalizedIdent\nLiteral = LowerCaseIdent\n\nLowerCaseIdent = \"a\" .. \"z\" identRest*\nCapitalizedIdent = \"A\" .. \"Z\" identRest*\n\nidentRest = \"0-9\" | \"_\" | \"A\" .. \"Z\" | \"a\" .. \"z\"\n}"
  },
  {
    "objectID": "posts/2021-10-29-dsl-datalog-ohm-glue.html#glue",
    "href": "posts/2021-10-29-dsl-datalog-ohm-glue.html#glue",
    "title": "A toy Datalog parser using Ohm and Glue.",
    "section": "Glue",
    "text": "Glue\nNow that we have the Ohm grammar, it’s time to use it to assign some meaning to the parse tree that it’ll generate from our sample Datalog program. Ohm actually already allows us to do that too.\nHowever, Paul Tarvydas found that he was writing a lot of boilerplate code and decided to ….. write another DSL for it! It’s called Glue.\nCAUTION: Glue is a prototype and does not cover all edge cases.\nThe way Glue works is you take all the symbols in your Ohm grammar e.g. Clause, ID and write a corresponding piece of JavaScript code to be generated. Glue also simplifies it in the way that you can just write the string of code(Python in my case) that you want to generate. Let’s start with a dummy example.\nProgram [@Statement] = [[ ${Statement} ]]\nHere, Program and Statement are from the Ohm grammar above. Since we have multiple statements, we use @ to indicate that. The code to be generated is between [[ and ]]. And we refer to the code with JavaScript interpolation code ${}. What is the value of Statement above? Well, it’ll be populated ‘somehow’ by Ohm with the values from the rest of the grammar.\nI think the above example was too easy for you :) . Let’s show you what I have to actually do.\nIf you look at my required Python Mercylog code above, I need to first generate some generic, wrapper like Python code like mercylog import statements and initialization no matter what the Datalog code is to be generated.\n\nfrom mercylog import R, V, and_, db\nfb = [ .. statements ..] # refer to facts_rules_query above \nds = db() \nresult = ds(fb)\nprint(result.df()) \nThe way we specify that in Glue is:\nProgram [@Statement] = [[from mercylog import R, V, and_, db\\nfb = \\[ ${Statement}\\] \\nds = db() \\nresult = ds(fb) \\nprint(result.df()) ]]\nIt may not look very clean and Paul may have some way to improve on this but I just wanted to give you an idea.\nWe need to escape special characters in Glue. For e.g., I have to use [] for Python but that means something in Glue too so I have to escape it e.g. \\[\nWhere do we get statements from? Well, there was something I didn’t mention before, that it’s time to talk about now. Notice the -- rule and -- fact in our Ohm grammar?\nStatement =\n    Clause \".\"                          -- fact\n  | Clause \":-\" Clause CommaClause* \".\" -- rule\n\nThey look like comments but they are called case labels in Ohm. They are a way to specify different execution paths for Glue (actually, for Ohm, which Glue uses underneath). So we have two entries in Glue for Statement, Statement_fact and Statement_rule\nNote, that the number of parameters for e.g. Statement_fact match closely with how it’s grammar is specified. Using k in kperiod is just a convention, I think, to indicate that it’s a literal unlike the others.\nIf it’s a fact, I just have to add it to the list fb. The code containing fb is generated above for Program  [@statement]. So I take clause which will be generated later and just add a , to it, as I’m adding it to a Python list which wants a comma between list elements. For rules, I have to convert Statement_rule to the corresponding mercylog  statement i.e. clause1 << and_(...)\nStatement_fact [clause kperiod] = [[${clause},\\n]]\nStatement_rule [clause1 kcolondash clause @commaclause kdot] = [[${clause1} << and_(${clause}${commaclause}),\\n]]\n\nI think the rest of the code follows the same principles explained above.\nHere’s the final Glue Code.\nProgram [@Statement] = [[from mercylog import R, V, and_, db\\nfb = \\[ ${Statement}\\] \\nds = db() \\nresult = ds(fb) \\nprint(result.df()) ]]\nStatement_fact [clause kperiod] = [[${clause},\\n]]\nStatement_rule [clause1 kcolondash clause @commaclause kdot] = [[${clause1} << and_(${clause}${commaclause}),\\n]]\n\nClause [predicate klpar idlist krpar] = [[${predicate}(${idlist})]]\n\nCommaClause [kcomma clause] = [[\\,${clause}]]\n\nRelation [lowercaseident] = [[R.${lowercaseident}]]\nIDList [id @commaid] = [[${id}${commaid}]]\n\nID [id] = [[${id}]]\nCommaID [kcomma id] = [[\\, ${id}]]\n\nVariable [capident] = [[V.${capident}]]\nLiteral [lowercaseident] = [[\"${lowercaseident}\"]]\n\nLowerCaseIdent [c @cs] = [[${c}${cs}]]\n\nCapitalizedIdent [c @cs] = [[${c}${cs}]]\n\nidentRest [c] = [[${c}]]"
  },
  {
    "objectID": "posts/2021-10-29-dsl-datalog-ohm-glue.html#code-generation",
    "href": "posts/2021-10-29-dsl-datalog-ohm-glue.html#code-generation",
    "title": "A toy Datalog parser using Ohm and Glue.",
    "section": "Code Generation",
    "text": "Code Generation\nSo we have the Ohm and Glue grammars. We can now take a Datalog program and generate Python code. Using the pfr tool in the repo parse tool which reads an Ohm, Glue file and input source language file, we can generate the Python code.\npfr test.datalog datalog.ohm mercylog.glue > test.py \n\nNOTE: I had to hack the code above a bit to make it work for me but Paul may have updated his repo to make it work seamlessly for all. The emphasis here is not on having production ready tools but to rapidly explore ideas in DSL building and get feedback.\nThat generates\nfrom mercylog import R, V, and_, db\nfb = [ R.parent(\"abe\", \"bob\"),\nR.parent(\"abby\", \"bob\"),\nR.parent(\"bob\", \"carl\"),\nR.parent(\"bob\", \"connor\"),\nR.parent(\"beatrice\", \"carl\"),\nR.man(\"abe\"),\nR.man(\"bob\"),\nR.woman(\"abby\"),\nR.woman(\"beatrice\"),\nR.father(V.X, V.Y) << and_(R.man(V.X),R.parent(V.X, V.Y)),\nR.father(V.X, V.Y),\n] \nds = db() \nresult = ds(fb) \nprint(result.df()) \nNot that it’s not indented properly, nor have I done any optimizations. For e.g. V.X could be refactored to X=V.X like in the Python code showed in the very beginning. But that’s another exercise.\nNow to test my code, I have to create a project with mercylog in my dependencies and then do\npython test.py\n\nand I’ll see\n      Y    X\n0  connor  bob\n1     bob  abe\n2    carl  bob"
  },
  {
    "objectID": "posts/2020-02-16-introducing-mercylog.html",
    "href": "posts/2020-02-16-introducing-mercylog.html",
    "title": "Introduction to Datalog(Bashlog) in Python.",
    "section": "",
    "text": "TLDR:\nDatalog is like SQL + Recursion. It’s derivatives have reduced the code base by 50% or more.\n\n\nDatalog\nToday, I would like to explore a constrained language called Datalog. It’s a constrained form of Prolog and may not be as expressive as C++ or Python. But it’s derivatives have been known to reduce the numbers of lines of code down by 50% or more(Overlog, Yedalog).\nLet’s get started:\nDatalog has a minimalist syntax which I love. Let’s take an example. Suppose our data is about fathers and sons, mothers and daughters. If we had an excel sheet, we would enter the data like:\nFather  Son\nAks     Bob\nBob     Cad\nYan     Zer\nand another excel sheet for mothers and daughters:\nMother  Daughter\nMary    Marla\nMarla   Kay\nJane    Zanu\nIn Datalog, we express the same data as(together):\nfather('Aks', 'Bob')\nfather('Bob', 'Cad')\nfather('Yan', 'Zer')\nmother('Mary', 'Marla')\nmother('Marla', 'Kay')\nmother('Jane', 'Zanu')\nHere we are trying to say Aks is the father of ‘Bob’ and ‘Bob’ is the father of ‘Cad’. The datum father(‘Aks’, ‘Bob’) is called a fact i.e. it is true.\nSo Datalog can be used to express data. Not very interesting so far but a building block. These facts above can also be viewed as the existing state of the system, like we store state in files, or databases.\nBut that’s not enough. What about code? For Datalog, code are specified as rules to be applied declaratively.\nLet’s say our program needs to find out who’s a grandfather. We could write a rule like: ‘A person X is the grandfather of Z if X is the father of Y and Y is the father of Z’. In Datalog, this rule is written as:\ngrandfather(X, Z) :- father(X,Y), father(Y, Z)\nThe LHS (i.e. grandfather) is known as the head and the RHS after the :- is known as the body\nX, Y, Z are special variables called logic variables. They are different from regular variables. They are more used to represent a pattern or to link the head and the body.\nTo further understand logical variables, consider these two rules:\ngrandfather(X, Z) :- father(X,Y), father(Y, Z)\ngrandmother(X, Z) :- mother(X,Y), mother(Y, Z)\nHere the X, Z and Y used in grandfather are completely different from the X, Y and Z in grandmother. In rules, the variables only make sense in that single rule. So we can reuse the same logic variables in different rules without worrying that they have some logical connection.\nThe next concept is queries. How do we feed input and get back some output. Queries are similar to rules but without a head.\nfather(X, 'Aks'), mother(Z, 'Aks')\n \nwe mean, find the mother and father of ‘Aks’ or\nfather(X, 'Raj'), mother(Z, 'Raj')\nwe mean, find the father and mother of ‘Raj’\nSuppose, we want to say find the mother and father of all the children in the database, we make the query\nfather(X, Y), mother(Z, Y) \nDatalog will link Y for all mother and father facts and find the mothers and fathers for a child. It will not mix up fathers and mothers :)\nNow, If you opened a datalog interpreter and fed the above and made the following queries, you would get the results shown after the # sign\nfather(X,_) # ['Aks', 'Bob', 'Yan']\nfather(_,X) # ['Bob', 'Cad', 'Zer']\nfather(X, Y) # [('Aks', 'Bob'), ('Bob', 'Cad'), ('Yan', 'Zer')\nfather(X, 'Zer'), father('Zer', Y) # [] as there are no facts that match the query\ngrandfather(X, Y) # [('Aks', 'Cad')]\ngrandfather(X,_) # ['Aks']\nHere ’_’ is a special variable indicating that you don’t care for the result.\nI was always interested in the Datalog syntax and it’s power. I kept delaying it until I met Bashlog. Because, the syntax of datalog is so simple, it makes it easy to write interpeters for different targets. What Bashlog did was take Datalog syntax and convert it to bash scripts! Because, it used awk(mawk actually), sed, grep, which are tuned for high performance on Unix like platforms, it was incredibly fast in parsing big text files, comparable with all the specialized databases out there. Just Bash Scripts. It blew my mind. So if you are interested in pure Datalog, check out Bashlog\nWith Bashlog, you can run any bash like command and read that using Bashlog. Imagine there was a file(‘~/data.tsv’) with tab separated values of\nAks Bob\nBob Cad\nYan Zer\nWe could read that data like:\nfacts(F, S) :~ cat ~/data.tsv\nfather(X, Y) :- facts(X, Y)\nAnd then we proceed the same manner like before. What’s awesome is that you can run any Unix command(e.g. ls -l) as long as it returns an output of tab separated values.\nBut I wanted to use Datalog in my day to day programming. I wanted to see if I could use and leverage Datalog along with Python. Some benefits of Datalog in Python are:\n\nModularity. How do we abstract out patterns in our rules and facts.\nPossible access to exisitng rich source of libraries.\n\nSo I built Mercylog in Python.\nSo let’s translate the above rules to Mercylog syntax.\n\n\nInstallation\nIf you are using the Bashlog variant, - then you need Java 8 already installed\ngit clone https://github.com/RAbraham/mercylog_tutorial.git\ncd mercylog_tutorial\npython3 -m venv venv\nsource venv/bin/activate\npip install -r requirements.txt\npython tutorial.py\nThat should print\n['Aks']\n['Mary']\nRead below on the explanation and make tweaks if you want and run python tutorial.py again.\n\n\nUsage\nimport mercylog\nm = mercylog.BashlogV1()\n\n# father('Aks', 'Bob')\n# father('Bob', 'Cad')\n# father('Yan', 'Zer')\n# mother('Mary', 'Marla')\n# mother('Marla', 'Kay')\n# mother('Jane', 'Zanu')\n\nfather = m.relation('father')\nmother = m.relation('mother')\nfacts = [\n    father('Aks', 'Bob'),\n    father('Bob', 'Cad'),\n    father('Yan', 'Zer'),\n    mother('Mary', 'Marla'),\n    mother('Marla', 'Kay'),\n    mother('Jane', 'Zanu'),\n] \n# grandfather(X, Z) :- father(X,Y), father(Y, Z)\ngrandfather = m.relation('grandfather')\nX, Y, Z = m.variables('X', 'Y', 'Z') \ngrandfather(X, Z) <= [father(X, Y), father(Y, Z)]\nWhile in Datalog, you don’t have to explicitly state the variables and the relation, as it is baked in to the language, in our library in Python, we need to (e.g. X, Y, Z and father, grandfather)\nMaking a query in python has the following syntax\nm.run(facts, rules, query)\nA concrete example would be:\nm.run(facts, rules, grandfather(X, Y)) # which gives [('Aks', 'Cad')]\nm.run(facts, rules, father(X,_)) # ['Aks', 'Bob', 'Yan']\nm.run(facts, rules,father(_,X)) # ['Bob', 'Cad', 'Zer']\nm.run(facts, rules,father(X, Y)) # [('Aks', 'Bob'), ('Bob', 'Cad'), ('Yan', 'Zer')\nm.run(facts, rules, granfather(X,_)) # ['Aks']\nCreating this DSL in python gives us some unique benefits. For e.g if we had these two relations\npaternal_grandfather = m.relation('paternal_grandfather')\nmaternal_grandmother = m.relation('maternal_grandmother')\nfather = m.relation('father')\nmother = m.relation('mother')\n\nX, Y, Z = m.variables('X', 'Y', 'Z')\nrules = [\n    paternal_grandfather(X, Z) <= [father(X, Y), father(Y, Z)],\n    maternal_grandmother(X, Z) <= [mother(X, Y), mother(Y, Z)]\n] \nIf you notice, the rule for paternal_grandfather and maternal_grandmother are very similar. I could perhaps encapsulate that into a function. I’ll use the word transitive though I believe it is incorrect to use it.. but I don’t know what to call this for now. Rewriting the above code:\n\ndef transitive(head, clause):\n    X, Y, Z = m.variables('X', 'Y', 'Z')\n    return head(X, Z) <= [clause(X, Y), clause(Y, Z)]\n\npaternal_grandfather = m.relation('paternal_grandfather')\nmaternal_grandmother = m.relation('maternal_grandmother')\nfather = m.relation('father')\nmother = m.relation('mother')\n\n\nrules = [\n    transitive(paternal_grandfather, father),\n    transitive(maternal_grandmother, mother)\n]     \nIn this way, using Python, we have modularized a pattern using the transitive function.\nLet’s recap the benefits of Mercylog - Simple Syntax. All you need to know is facts and rules. Because of such simplicity, it is also easy to build compilers for it. - Expressive. Rules give a powerful mechanism - Declarative. Like SQL but more expressive. So we can optimize it’s engines without affecting the code\nI’ll continue to update you with my future learnings!"
  }
]